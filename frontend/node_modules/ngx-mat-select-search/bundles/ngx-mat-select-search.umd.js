(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/forms'), require('@angular/cdk/keycodes'), require('rxjs'), require('rxjs/operators'), require('@angular/core'), require('@angular/material'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-mat-select-search', ['exports', '@angular/forms', '@angular/cdk/keycodes', 'rxjs', 'rxjs/operators', '@angular/core', '@angular/material', '@angular/common'], factory) :
    (factory((global['ngx-mat-select-search'] = {}),global.ng.forms,global.ng.cdk.keycodes,global.rxjs,global.rxjs.operators,global.ng.core,global.ng.material,global.ng.common));
}(this, (function (exports,forms,keycodes,rxjs,operators,core,material,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Directive for providing a custom clear-icon.
     * e.g.
     * <ngx-mat-select-search [formControl]="bankFilterCtrl">
     *   <mat-icon ngxMatSelectSearchClear>delete</mat-icon>
     * </ngx-mat-select-search>
     */
    var MatSelectSearchClearDirective = /** @class */ (function () {
        function MatSelectSearchClearDirective() {
        }
        MatSelectSearchClearDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngxMatSelectSearchClear]'
                    },] }
        ];
        return MatSelectSearchClearDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /* tslint:disable:member-ordering component-selector */
    /**
     * Component providing an input field for searching MatSelect options.
     *
     * Example usage:
     *
     * interface Bank {
     *  id: string;
     *  name: string;
     * }
     *
     * \@Component({
     *   selector: 'my-app-data-selection',
     *   template: `
     *     <mat-form-field>
     *       <mat-select [formControl]="bankCtrl" placeholder="Bank">
     *         <ngx-mat-select-search [formControl]="bankFilterCtrl"></ngx-mat-select-search>
     *         <mat-option *ngFor="let bank of filteredBanks | async" [value]="bank.id">
     *           {{bank.name}}
     *         </mat-option>
     *       </mat-select>
     *     </mat-form-field>
     *   `
     * })
     * export class DataSelectionComponent implements OnInit, OnDestroy {
     *
     *   // control for the selected bank
     *   public bankCtrl: FormControl = new FormControl();
     *   // control for the MatSelect filter keyword
     *   public bankFilterCtrl: FormControl = new FormControl();
     *
     *   // list of banks
     *   private banks: Bank[] = [{name: 'Bank A', id: 'A'}, {name: 'Bank B', id: 'B'}, {name: 'Bank C', id: 'C'}];
     *   // list of banks filtered by search keyword
     *   public filteredBanks: ReplaySubject<Bank[]> = new ReplaySubject<Bank[]>(1);
     *
     *   // Subject that emits when the component has been destroyed.
     *   private _onDestroy = new Subject<void>();
     *
     *
     *   ngOnInit() {
     *     // load the initial bank list
     *     this.filteredBanks.next(this.banks.slice());
     *     // listen for search field value changes
     *     this.bankFilterCtrl.valueChanges
     *       .pipe(takeUntil(this._onDestroy))
     *       .subscribe(() => {
     *         this.filterBanks();
     *       });
     *   }
     *
     *   ngOnDestroy() {
     *     this._onDestroy.next();
     *     this._onDestroy.complete();
     *   }
     *
     *   private filterBanks() {
     *     if (!this.banks) {
     *       return;
     *     }
     *
     *     // get the search keyword
     *     let search = this.bankFilterCtrl.value;
     *     if (!search) {
     *       this.filteredBanks.next(this.banks.slice());
     *       return;
     *     } else {
     *       search = search.toLowerCase();
     *     }
     *
     *     // filter the banks
     *     this.filteredBanks.next(
     *       this.banks.filter(bank => bank.name.toLowerCase().indexOf(search) > -1)
     *     );
     *   }
     * }
     */
    var MatSelectSearchComponent = /** @class */ (function () {
        function MatSelectSearchComponent(matSelect, changeDetectorRef, matOption) {
            if (matOption === void 0) {
                matOption = null;
            }
            this.matSelect = matSelect;
            this.changeDetectorRef = changeDetectorRef;
            this.matOption = matOption;
            /**
             * Label of the search placeholder
             */
            this.placeholderLabel = 'Suche';
            /**
             * Label to be shown when no entries are found. Set to null if no message should be shown.
             */
            this.noEntriesFoundLabel = 'Keine Optionen gefunden';
            /**
             * Whether or not the search field should be cleared after the dropdown menu is closed.
             * Useful for server-side filtering. See [#3](https://github.com/bithost-gmbh/ngx-mat-select-search/issues/3)
             */
            this.clearSearchInput = true;
            /**
             * Whether to show the search-in-progress indicator
             */
            this.searching = false;
            /**
             * Disables initial focusing of the input field
             */
            this.disableInitialFocus = false;
            this.onChange = function (_) { };
            this.onTouched = function (_) { };
            /**
             * Whether the backdrop class has been set
             */
            this.overlayClassSet = false;
            /**
             * Event that emits when the current value changes
             */
            this.change = new core.EventEmitter();
            /**
             * Subject that emits when the component has been destroyed.
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(MatSelectSearchComponent.prototype, "isInsideMatOption", {
            get: /**
             * @return {?}
             */ function () {
                return !!this.matOption;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatSelectSearchComponent.prototype, "value", {
            /** Current search value */
            get: /**
             * Current search value
             * @return {?}
             */ function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatSelectSearchComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // set custom panel class
                /** @type {?} */
                var panelClass = 'mat-select-search-panel';
                if (this.matSelect.panelClass) {
                    if (Array.isArray(this.matSelect.panelClass)) {
                        this.matSelect.panelClass.push(panelClass);
                    }
                    else if (typeof this.matSelect.panelClass === 'string') {
                        this.matSelect.panelClass = [this.matSelect.panelClass, panelClass];
                    }
                    else if (typeof this.matSelect.panelClass === 'object') {
                        this.matSelect.panelClass[panelClass] = true;
                    }
                }
                else {
                    this.matSelect.panelClass = panelClass;
                }
                // set custom mat-option class if the component was placed inside a mat-option
                if (this.matOption) {
                    this.matOption.disabled = true;
                    this.matOption._getHostElement().classList.add('contains-mat-select-search');
                }
                // when the select dropdown panel is opened or closed
                this.matSelect.openedChange
                    .pipe(operators.delay(1), operators.takeUntil(this._onDestroy))
                    .subscribe(function (opened) {
                    if (opened) {
                        // focus the search field when opening
                        _this.getWidth();
                        if (!_this.disableInitialFocus) {
                            _this._focus();
                        }
                    }
                    else {
                        // clear it when closing
                        if (_this.clearSearchInput) {
                            _this._reset();
                        }
                    }
                });
                // set the first item active after the options changed
                this.matSelect.openedChange
                    .pipe(operators.take(1))
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () {
                    _this._options = _this.matSelect.options;
                    _this._options.changes
                        .pipe(operators.takeUntil(_this._onDestroy))
                        .subscribe(function () {
                        /** @type {?} */
                        var keyManager = _this.matSelect._keyManager;
                        if (keyManager && _this.matSelect.panelOpen) {
                            // avoid "expression has been changed" error
                            setTimeout(function () {
                                // set first item active and input width
                                keyManager.setFirstItemActive();
                                _this.getWidth();
                                // set no entries found class on mat option
                                if (_this.matOption) {
                                    if (_this._noEntriesFound()) {
                                        _this.matOption._getHostElement().classList.add('mat-select-search-no-entries-found');
                                    }
                                    else {
                                        _this.matOption._getHostElement().classList.remove('mat-select-search-no-entries-found');
                                    }
                                }
                            }, 1);
                        }
                    });
                });
                // detect changes when the input changes
                this.change
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () {
                    _this.changeDetectorRef.detectChanges();
                });
                this.initMultipleHandling();
            };
        /**
         * @return {?}
         */
        MatSelectSearchComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        MatSelectSearchComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.setOverlayClass();
                // update view when available options change
                this.matSelect.openedChange
                    .pipe(operators.take(1), operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.matSelect.options.changes
                        .pipe(operators.takeUntil(_this._onDestroy))
                        .subscribe(function () {
                        _this.changeDetectorRef.markForCheck();
                    });
                });
            };
        /**
         * Handles the key down event with MatSelect.
         * Allows e.g. selecting with enter key, navigation with arrow keys, etc.
         * @param event
         */
        /**
         * Handles the key down event with MatSelect.
         * Allows e.g. selecting with enter key, navigation with arrow keys, etc.
         * @param {?} event
         * @return {?}
         */
        MatSelectSearchComponent.prototype._handleKeydown = /**
         * Handles the key down event with MatSelect.
         * Allows e.g. selecting with enter key, navigation with arrow keys, etc.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Prevent propagation for all alphanumeric characters in order to avoid selection issues
                if ((event.key && event.key.length === 1) ||
                    (event.keyCode >= keycodes.A && event.keyCode <= keycodes.Z) ||
                    (event.keyCode >= keycodes.ZERO && event.keyCode <= keycodes.NINE) ||
                    (event.keyCode === keycodes.SPACE)) {
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        MatSelectSearchComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var valueChanged = value !== this._value;
                if (valueChanged) {
                    this._value = value;
                    this.change.emit(value);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        MatSelectSearchComponent.prototype.onInputChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var valueChanged = value !== this._value;
                if (valueChanged) {
                    this.initMultiSelectedValues();
                    this._value = value;
                    this.onChange(value);
                    this.change.emit(value);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        MatSelectSearchComponent.prototype.onBlur = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.writeValue(value);
                this.onTouched();
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        MatSelectSearchComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        MatSelectSearchComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouched = fn;
            };
        /**
         * Focuses the search input field
         */
        /**
         * Focuses the search input field
         * @return {?}
         */
        MatSelectSearchComponent.prototype._focus = /**
         * Focuses the search input field
         * @return {?}
         */
            function () {
                if (!this.searchSelectInput || !this.matSelect.panel) {
                    return;
                }
                // save and restore scrollTop of panel, since it will be reset by focus()
                // note: this is hacky
                /** @type {?} */
                var panel = this.matSelect.panel.nativeElement;
                /** @type {?} */
                var scrollTop = panel.scrollTop;
                // focus
                this.searchSelectInput.nativeElement.focus();
                panel.scrollTop = scrollTop;
            };
        /**
         * Resets the current search value
         * @param focus whether to focus after resetting
         */
        /**
         * Resets the current search value
         * @param {?=} focus whether to focus after resetting
         * @return {?}
         */
        MatSelectSearchComponent.prototype._reset = /**
         * Resets the current search value
         * @param {?=} focus whether to focus after resetting
         * @return {?}
         */
            function (focus) {
                if (!this.searchSelectInput) {
                    return;
                }
                this.searchSelectInput.nativeElement.value = '';
                this.onInputChange('');
                if (this.matOption && !focus) {
                    // remove no entries found class on mat option
                    this.matOption._getHostElement().classList.remove('mat-select-search-no-entries-found');
                }
                if (focus) {
                    this._focus();
                }
            };
        /**
         * Sets the overlay class  to correct offsetY
         * so that the selected option is at the position of the select box when opening
         */
        /**
         * Sets the overlay class  to correct offsetY
         * so that the selected option is at the position of the select box when opening
         * @private
         * @return {?}
         */
        MatSelectSearchComponent.prototype.setOverlayClass = /**
         * Sets the overlay class  to correct offsetY
         * so that the selected option is at the position of the select box when opening
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.overlayClassSet) {
                    return;
                }
                /** @type {?} */
                var overlayClasses = ['cdk-overlay-pane-select-search'];
                if (!this.matOption) {
                    // add offset to panel if component is not placed inside mat-option
                    overlayClasses.push('cdk-overlay-pane-select-search-with-offset');
                }
                this.matSelect.overlayDir.attach
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () {
                    // note: this is hacky, but currently there is no better way to do this
                    /** @type {?} */
                    var element = _this.searchSelectInput.nativeElement;
                    /** @type {?} */
                    var overlayElement;
                    while (element = element.parentElement) {
                        if (element.classList.contains('cdk-overlay-pane')) {
                            overlayElement = element;
                            break;
                        }
                    }
                    if (overlayElement) {
                        overlayClasses.forEach(function (overlayClass) {
                            overlayElement.classList.add(overlayClass);
                        });
                    }
                });
                this.overlayClassSet = true;
            };
        /**
         * Initializes handling <mat-select [multiple]="true">
         * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
         */
        /**
         * Initializes handling <mat-select [multiple]="true">
         * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
         * @private
         * @return {?}
         */
        MatSelectSearchComponent.prototype.initMultipleHandling = /**
         * Initializes handling <mat-select [multiple]="true">
         * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                // if <mat-select [multiple]="true">
                // store previously selected values and restore them when they are deselected
                // because the option is not available while we are currently filtering
                this.matSelect.valueChange
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (values) {
                    if (_this.matSelect.multiple) {
                        /** @type {?} */
                        var restoreSelectedValues_1 = false;
                        if (_this._value && _this._value.length
                            && _this.previousSelectedValues && Array.isArray(_this.previousSelectedValues)) {
                            if (!values || !Array.isArray(values)) {
                                values = [];
                            }
                            /** @type {?} */
                            var optionValues_1 = _this.matSelect.options.map(function (option) { return option.value; });
                            _this.previousSelectedValues.forEach(function (previousValue) {
                                if (values.indexOf(previousValue) === -1 && optionValues_1.indexOf(previousValue) === -1) {
                                    // if a value that was selected before is deselected and not found in the options, it was deselected
                                    // due to the filtering, so we restore it.
                                    values.push(previousValue);
                                    restoreSelectedValues_1 = true;
                                }
                            });
                        }
                        if (restoreSelectedValues_1) {
                            _this.matSelect._onChange(values);
                        }
                        _this.previousSelectedValues = values;
                    }
                });
            };
        /**
         *  Set the width of the innerSelectSearch to fit even custom scrollbars
         *  And support all Operation Systems
         */
        /**
         *  Set the width of the innerSelectSearch to fit even custom scrollbars
         *  And support all Operation Systems
         * @private
         * @return {?}
         */
        MatSelectSearchComponent.prototype.getWidth = /**
         *  Set the width of the innerSelectSearch to fit even custom scrollbars
         *  And support all Operation Systems
         * @private
         * @return {?}
         */
            function () {
                if (!this.innerSelectSearch || !this.innerSelectSearch.nativeElement) {
                    return;
                }
                /** @type {?} */
                var element = this.innerSelectSearch.nativeElement;
                /** @type {?} */
                var panelElement;
                while (element = element.parentElement) {
                    if (element.classList.contains('mat-select-panel')) {
                        panelElement = element;
                        break;
                    }
                }
                if (panelElement) {
                    this.innerSelectSearch.nativeElement.style.width = panelElement.clientWidth + 'px';
                }
            };
        /**
         *  Initialize this.previousSelectedValues once the first filtering occurs.
         */
        /**
         *  Initialize this.previousSelectedValues once the first filtering occurs.
         * @return {?}
         */
        MatSelectSearchComponent.prototype.initMultiSelectedValues = /**
         *  Initialize this.previousSelectedValues once the first filtering occurs.
         * @return {?}
         */
            function () {
                if (this.matSelect.multiple && !this._value) {
                    this.previousSelectedValues = this.matSelect.options
                        .filter(function (option) { return option.selected; })
                        .map(function (option) { return option.value; });
                }
            };
        /**
         * Returns whether the "no entries found" message should be displayed
         */
        /**
         * Returns whether the "no entries found" message should be displayed
         * @return {?}
         */
        MatSelectSearchComponent.prototype._noEntriesFound = /**
         * Returns whether the "no entries found" message should be displayed
         * @return {?}
         */
            function () {
                if (!this._options) {
                    return;
                }
                if (this.matOption) {
                    return this.noEntriesFoundLabel && this.value && this._options.length === 1;
                }
                else {
                    return this.noEntriesFoundLabel && this.value && this._options.length === 0;
                }
            };
        MatSelectSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-mat-select-search',
                        template: "<!-- Placeholder to adjust vertical offset of the mat-option elements -->\n<input matInput class=\"mat-select-search-input mat-select-search-hidden\"/>\n\n<!-- Note: the  mat-datepicker-content mat-tab-header are needed to inherit the material theme colors, see PR #22 -->\n<div\n      #innerSelectSearch\n      class=\"mat-select-search-inner mat-typography mat-datepicker-content mat-tab-header\"\n      [ngClass]=\"{'mat-select-search-inner-multiple': matSelect.multiple}\">\n  <input matInput\n         class=\"mat-select-search-input\"\n         autocomplete=\"off\"\n         #searchSelectInput\n         (keydown)=\"_handleKeydown($event)\"\n         (input)=\"onInputChange($event.target.value)\"\n         (blur)=\"onBlur($event.target.value)\"\n         [placeholder]=\"placeholderLabel\"\n  />\n  <mat-spinner *ngIf=\"searching\"\n          class=\"mat-select-search-spinner\"\n          diameter=\"16\"></mat-spinner>\n\n  <button mat-button *ngIf=\"value && !searching\"\n          mat-icon-button\n          aria-label=\"Clear\"\n          (click)=\"_reset(true)\"\n          class=\"mat-select-search-clear\">\n    <ng-content *ngIf=\"clearIcon; else defaultIcon\" select=\"[ngxMatSelectSearchClear]\"></ng-content>\n    <ng-template #defaultIcon>\n      <mat-icon>close</mat-icon>\n    </ng-template>\n  </button>\n</div>\n\n<div *ngIf=\"_noEntriesFound()\"\n     class=\"mat-select-search-no-entries-found\">\n  {{noEntriesFoundLabel}}\n</div>\n<!--\nCopyright (c) 2018 Bithost GmbH All Rights Reserved.\n\nUse of this source code is governed by an MIT-style license that can be\nfound in the LICENSE file at https://angular.io/license\n-->\n",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef(function () { return MatSelectSearchComponent; }),
                                multi: true
                            }
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".mat-select-search-hidden{visibility:hidden}.mat-select-search-inner{position:absolute;top:0;width:100%;border-bottom-width:1px;border-bottom-style:solid;z-index:100;font-size:inherit;box-shadow:none;border-radius:0;-webkit-transform:translate3d(0,0,0)}.mat-select-search-inner.mat-select-search-inner-multiple{width:100%}/deep/ .mat-select-search-panel{-webkit-transform:none!important;transform:none!important;overflow-x:hidden}.mat-select-search-input{padding:16px 36px 16px 16px;box-sizing:border-box}.mat-select-search-no-entries-found{padding:16px}.mat-select-search-clear{position:absolute;right:4px;top:5px}.mat-select-search-spinner{position:absolute;right:16px;top:calc(50% - 8px)}:host.mat-select-search-inside-mat-option .mat-select-search-input{padding-top:0;padding-bottom:0;height:3em;line-height:3em}:host.mat-select-search-inside-mat-option .mat-select-search-clear{top:3px}/deep/ .cdk-overlay-pane-select-search.cdk-overlay-pane-select-search-with-offset{margin-top:-50px}/deep/ .mat-option[aria-disabled=true].contains-mat-select-search{position:static;padding:0}/deep/ .mat-option[aria-disabled=true].contains-mat-select-search .mat-icon{margin-right:0}/deep/ .mat-option[aria-disabled=true].contains-mat-select-search .mat-option-pseudo-checkbox{display:none}/deep/ .mat-option[aria-disabled=true].contains-mat-select-search.mat-select-search-no-entries-found{height:6em}"]
                    }] }
        ];
        /** @nocollapse */
        MatSelectSearchComponent.ctorParameters = function () {
            return [
                { type: material.MatSelect, decorators: [{ type: core.Inject, args: [material.MatSelect,] }] },
                { type: core.ChangeDetectorRef },
                { type: material.MatOption, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MatOption,] }] }
            ];
        };
        MatSelectSearchComponent.propDecorators = {
            placeholderLabel: [{ type: core.Input }],
            noEntriesFoundLabel: [{ type: core.Input }],
            clearSearchInput: [{ type: core.Input }],
            searching: [{ type: core.Input }],
            disableInitialFocus: [{ type: core.Input }],
            searchSelectInput: [{ type: core.ViewChild, args: ['searchSelectInput', { read: core.ElementRef },] }],
            innerSelectSearch: [{ type: core.ViewChild, args: ['innerSelectSearch', { read: core.ElementRef },] }],
            clearIcon: [{ type: core.ContentChild, args: [MatSelectSearchClearDirective,] }],
            isInsideMatOption: [{ type: core.HostBinding, args: ['class.mat-select-search-inside-mat-option',] }]
        };
        return MatSelectSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MatSelectSearchVersion = '1.6.0';
    var NgxMatSelectSearchModule = /** @class */ (function () {
        function NgxMatSelectSearchModule() {
        }
        NgxMatSelectSearchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatButtonModule,
                            material.MatIconModule,
                            material.MatInputModule,
                            material.MatProgressSpinnerModule
                        ],
                        declarations: [
                            MatSelectSearchComponent,
                            MatSelectSearchClearDirective
                        ],
                        exports: [
                            MatSelectSearchComponent,
                            MatSelectSearchClearDirective
                        ]
                    },] }
        ];
        return NgxMatSelectSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.MatSelectSearchComponent = MatSelectSearchComponent;
    exports.MatSelectSearchVersion = MatSelectSearchVersion;
    exports.NgxMatSelectSearchModule = NgxMatSelectSearchModule;
    exports.ɵa = MatSelectSearchClearDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-mat-select-search.umd.js.map